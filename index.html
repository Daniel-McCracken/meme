<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MemeStream</title>

  <!-- Configure Tailwind to use 'class' strategy for dark mode -->
  <script>
    window.tailwind = window.tailwind || {};
    window.tailwind.config = {
      darkMode: 'class',
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    /* Basic transition for potential manual dark mode toggle or image backgrounds */
    html {
      transition: background-color 0.3s ease, color 0.3s ease;
    }
    img {
      transition: background-color 0.3s ease;
    }
  </style>
</head>
<!-- 
  To enable dark mode by default, manually add 'class="dark"' to the <html> tag:
  <html lang="en" class="dark">
-->
<body class="bg-white text-black">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useRef, useState, useCallback } = React;

    /**
     * MemeStream – TikTok-style meme viewer (React + Tailwind)
     * - Funniest first (ranked by upvotes when available)
     * - Infinite scroll + lazy images + mobile swipe + Next button
     * - Session-only Likes (heart)
      * - Date filtering: Month & Year (client-side)
     * - Robust offline fallback if external fetch is blocked (sample memes as data URLs)
     * - Built-in lightweight test runner (no dependencies) – toggle with ?tests=1
     */

    /*************************
     * ---- CONFIG / UTILS ----
     *************************/
    const SUBREDDITS = ["memes", "dankmemes", "wholesomememes", "me_irl", "funny", "AdviceAnimals"];
    const BATCH_SIZE = 24; // per network attempt
    const MAX_QUEUE = 240; // cap in-memory list to avoid bloat
    const FETCH_TIMEOUT_MS = 5500;

    const isImageOrGif = (url) => {
      const inputUrl = url || "";
      return /^data:image\/(png|jpe?g|gif|webp|svg\+xml)/i.test(inputUrl) || /\.(png|jpe?g|gif|webp|svg)(\?.*)?$/i.test(inputUrl);
    };

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    function withNoCache(url) {
      const sep = url.includes('?') ? '&' : '?';
      return `${url}${sep}_=${Date.now()}`;
    }

    function timeoutFetch(url, opts = {}, ms = FETCH_TIMEOUT_MS) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), ms);
      return fetch(url, { ...opts, signal: ctrl.signal })
        .finally(() => clearTimeout(t));
    }

    function funnyScore(m) {
      const ups = Number(m.ups || 0);
      const ageHours = Math.max(1, (Date.now()/1000 - (m.created || Date.now()/1000)) / 3600);
      return ups / Math.log2(3 + ageHours);
    }

    function isWithinRange() { return true; }

    // removed month/year helpers

    function svgDataUrl(text) {
      const safe = String(text).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='1200' height='900'>\n  <defs>\n    <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>\n      <stop offset='0%' stop-color='#fafafa'/>\n      <stop offset='100%' stop-color='#ddd'/>\n    </linearGradient>\n  </defs>\n  <rect width='100%' height='100%' fill='url(#g)'/>\n  <g font-family='Inter,system-ui,Segoe UI,Arial' fill='#111'>\n    <text x='50%' y='46%' dominant-baseline='middle' text-anchor='middle' font-size='52' font-weight='700'>Meme (offline)</text>\n    <text x='50%' y='58%' dominant-baseline='middle' text-anchor='middle' font-size='28'>${safe}</text>\n  </g>\n</svg>`;
      return `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`;
    }

    // -- IMPROVED a small curated offline set with more recent dates for easier filter testing --
    const OFFLINE_MEMES = [
      { id: 'o1', title: 'Meme from this month (Aug 2025)', url: svgDataUrl('This is a recent meme'), author: 'devbot', subreddit: 'memes', ups: 5234, created: Date.UTC(2025, 7, 2)/1000 },
      { id: 'o2', title: 'Meme from last month (Jul 2025)', url: svgDataUrl('A slightly older meme'), author: 'explainlikeim5', subreddit: 'me_irl', ups: 8120, created: Date.UTC(2025, 6, 15)/1000 },
      { id: 'o3', title: 'Meme from early 2025', url: svgDataUrl('From back in January'), author: 'ops', subreddit: 'dankmemes', ups: 3012, created: Date.UTC(2025, 0, 21)/1000 },
      { id: 'o4', title: 'Meme from last year (2024)', url: svgDataUrl('A classic from 2024'), author: 'comp_sci', subreddit: 'programmerhumor', ups: 11899, created: Date.UTC(2024, 10, 9)/1000 },
      { id: 'o5', title: 'Meme from 2023', url: svgDataUrl('Golden oldie'), author: 'pm', subreddit: 'funny', ups: 6401, created: Date.UTC(2023, 3, 2)/1000 },
      { id: 'o6', title: 'Meme from 2022', url: svgDataUrl('Ancient history'), author: 'qa', subreddit: 'wholesomememes', ups: 920, created: Date.UTC(2022, 9, 30)/1000 },
    ];

    /***************************
     * ---- DATA FETCH LAYER ----
     ***************************/
    async function fetchFromMemeApi(count) {
      const sub = SUBREDDITS[Math.floor(Math.random() * SUBREDDITS.length)];
      // Fixed URL construction (removed extra space)
      const url = withNoCache(`https://meme-api.com/gimme/${sub}/${Math.max(1, Math.min(count, 50))}`);
      const res = await timeoutFetch(url, { headers: { Accept: 'application/json' }, cache: 'no-store' });
      if (!res.ok) throw new Error(`meme-api HTTP ${res.status}`);
      const data = await res.json();
      const list = (data.memes || []).filter(m => !m.nsfw && !m.spoiler && isImageOrGif(m.url));
      return list.map(m => ({
        id: m.postLink || m.url,
        title: m.title,
        url: m.url,
        author: m.author,
        subreddit: m.subreddit,
        postLink: m.postLink,
        ups: m.ups,
        created: m.created_utc || null,
        source: 'meme-api',
      }));
    }

    async function fetchFromReddit(count) {
      const sub = SUBREDDITS[Math.floor(Math.random() * SUBREDDITS.length)];
      // Fixed URL construction (removed extra space)
      const url = withNoCache(`https://www.reddit.com/r/${sub}/top/.json?limit=${Math.max(5, Math.min(count, 100))}&t=all`);
      const res = await timeoutFetch(url, { headers: { 'Accept': 'application/json' }, cache: 'no-store' });
      if (!res.ok) throw new Error(`reddit HTTP ${res.status}`);
      const data = await res.json();
      const list = (data.data?.children || []).map(({ data }) => ({
        id: data.id,
        title: data.title,
        url: data.url_overridden_by_dest || data.url,
        author: data.author,
        subreddit: data.subreddit,
        // Fixed URL construction (removed extra space)
        postLink: `https://reddit.com${data.permalink}`,
        ups: data.ups,
        created: data.created_utc,
        source: 'reddit',
      })).filter(m => isImageOrGif(m.url));
      return list;
    }

    async function fetchFromRandomApi(count) {
      const attempts = Math.max(1, Math.min(count, 10));
      const out = [];
      for (let i = 0; i < attempts; i++) {
        // Fixed URL (removed trailing space)
        const res = await timeoutFetch(withNoCache('https://some-random-api.com/meme'), { headers: { Accept: 'application/json' }, cache: 'no-store' });
        if (!res.ok) throw new Error(`random-api HTTP ${res.status}`);
        const data = await res.json();
        if (data && isImageOrGif(data.image)) {
          out.push({ id: data.id || data.image, title: data.caption || 'Meme', url: data.image, author: 'unknown', subreddit: 'random', postLink: data.url, ups: null, created: null, source: 'some-random-api' });
        }
        await sleep(50);
      }
      return out;
    }

    async function fetchBestEffort({ count }) {
      const tried = [];
      try {
        tried.push('meme-api');
        const a = await fetchFromMemeApi(count);
        if (a.length) return { items: a, source: 'meme-api', tried };
      } catch (e) { console.warn('meme-api failed', e); }
      try {
        tried.push('reddit');
        const b = await fetchFromReddit(count);
        if (b.length) return { items: b, source: 'reddit', tried };
      } catch (e) { console.warn('reddit failed', e); }
      try {
        tried.push('some-random-api');
        const c = await fetchFromRandomApi(Math.min(count, 8));
        if (c.length) return { items: c, source: 'some-random-api', tried };
      } catch (e) { console.warn('random-api failed', e); }
      return { items: OFFLINE_MEMES.slice(0, count), source: 'offline', tried };
    }

    /****************************
     * ---- REACT COMPONENTS ----
     * ThemeToggle component REMOVED
     ****************************/
     function App() {
      const [memes, setMemes] = useState([]);
      const [loading, setLoading] = useState(false);
      const [error, setError] = useState('');
      const [liked, setLiked] = useState(() => {
        try { const raw = sessionStorage.getItem('likedMemes'); return raw ? new Set(JSON.parse(raw)) : new Set(); } catch { return new Set(); }
      });
      // Removed date filters
      const [lastSource, setLastSource] = useState('');
      const [triedSources, setTriedSources] = useState([]);

      const feedRef = useRef(null);
      const headerRef = useRef(null);
      const [headerHeight, setHeaderHeight] = useState(0);
      const sentinelRef = useRef(null);
      const cardRefs = useRef([]);
      const currentIndexRef = useRef(0);

      useEffect(() => {
        try { sessionStorage.setItem('likedMemes', JSON.stringify(Array.from(liked))); } catch {}
      }, [liked]);

      React.useLayoutEffect(() => {
        const el = headerRef.current; if (!el) return;
        const update = () => setHeaderHeight(Math.ceil(el.offsetHeight || 0));
        update();
        const ro = new ResizeObserver(() => update());
        ro.observe(el);
        window.addEventListener('resize', update);
        return () => { ro.disconnect(); window.removeEventListener('resize', update); };
      }, []);

      // No active range; all memes allowed

      const fetchMemes = useCallback(async () => {
        if (loading) return;
        setLoading(true); setError('');
        const { items, source, tried } = await fetchBestEffort({ count: BATCH_SIZE });
        setLastSource(source); setTriedSources(tried);

        const normalized = items.map(m => ({ ...m, key: m.id || m.url }));
        const onlyImages = normalized.filter(m => isImageOrGif(m.url));
        const dedup = onlyImages.filter((m, idx, arr) => idx === arr.findIndex(x => x.key === m.key));

        // Anchor-based scroll stabilization: keep the first visible card pinned in place while appending
        let anchorEl = null; let preTop = 0;
        {
          for (let i = 0; i < cardRefs.current.length; i++) {
            const el = cardRefs.current[i];
            if (!el) continue;
            const r = el.getBoundingClientRect();
            if (r.bottom >= 0) { anchorEl = el; preTop = r.top; break; }
          }
        }

        setMemes(prev => {
          const isAppending = prev.length > 0;
          const allItems = isAppending ? [...prev, ...dedup] : [...dedup];
          const filtered = allItems.filter(m => isWithinRange(m));
          const uniqueFiltered = filtered.filter((m, idx, arr) => idx === arr.findIndex(x => x.key === m.key));
          uniqueFiltered.sort((a, b) => funnyScore(b) - funnyScore(a));
          if (uniqueFiltered.length > MAX_QUEUE) return uniqueFiltered.slice(0, MAX_QUEUE);
          return uniqueFiltered;
        });

        if (anchorEl) {
          requestAnimationFrame(() => {
            if (!document.body.contains(anchorEl)) return;
            const post = anchorEl.getBoundingClientRect();
            const delta = post.top - preTop;
            if (Math.abs(delta) > 1) {
              window.scrollBy({ top: delta, behavior: 'auto' });
            }
          });
        }
        setLoading(false);
      }, [loading]);

      useEffect(() => {
        setMemes([]);
        currentIndexRef.current = 0;
        if(feedRef.current) feedRef.current.scrollTop = 0;
        fetchMemes();
      }, []);

      useEffect(() => {
        const el = sentinelRef.current; if (!el) return;
        const io = new IntersectionObserver((entries) => {
          entries.forEach(e => { if (e.isIntersecting) fetchMemes(); });
        }, { root: null, rootMargin: '600px', threshold: 0 });
        io.observe(el); return () => io.disconnect();
      }, [fetchMemes]);

      useEffect(() => {
        const onKey = (e) => {
          if (["INPUT","TEXTAREA","SELECT"].includes(document.activeElement?.tagName)) return;
          const k = e.key.toLowerCase();
          if (k === 'j' || k === 'arrowdown') { e.preventDefault(); goToOffset(1); }
          else if (k === 'k' || k === 'arrowup') { e.preventDefault(); goToOffset(-1); }
          else if (k === 'l') { e.preventDefault(); const meme = memes[currentIndexRef.current]; if (meme) toggleLike(meme.id || meme.url); }
          else if (k === 't') { e.preventDefault(); setShowTests(v => !v); }
        };
        window.addEventListener('keydown', onKey); return () => window.removeEventListener('keydown', onKey);
      }, [memes]);

      const toggleLike = (id) => setLiked(prev => { const next = new Set(prev); next.has(id) ? next.delete(id) : next.add(id); return next; });

      const goToOffset = (delta) => {
        const nextIndex = Math.max(0, Math.min(memes.length - 1, currentIndexRef.current + delta));
        currentIndexRef.current = nextIndex;
        const node = cardRefs.current[nextIndex];
        if (node) {
          // Calculate header height to account for sticky positioning
          const header = document.querySelector('header');
          const headerHeight = header ? header.offsetHeight : 0;
          const offsetTop = node.offsetTop - headerHeight - 8;

          window.scrollTo({
            top: offsetTop,
            behavior: 'smooth'
          });
        }
      };

      useEffect(() => {
        let startY = 0, startX = 0; const threshold = 40;
        const onTouchStart = (e) => { startY = e.touches[0].clientY; startX = e.touches[0].clientX; };
        const onTouchEnd = (e) => {
          const dy = e.changedTouches[0].clientY - startY;
          const dx = e.changedTouches[0].clientX - startX;
          if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > threshold) { dy < 0 ? goToOffset(1) : goToOffset(-1); }
        };
        const el = feedRef.current; if (!el) return;
        el.addEventListener('touchstart', onTouchStart, { passive: true });
        el.addEventListener('touchend', onTouchEnd);
        return () => { el.removeEventListener('touchstart', onTouchStart); el.removeEventListener('touchend', onTouchEnd); };
      }, [memes.length]);

      const [showTests, setShowTests] = useState(() => new URLSearchParams(location.search).get('tests') === '1');
      const testResults = useMemo(() => runTests(), []);

      return (
        // Removed redundant bg/text classes here as they are now on <body>
        <div className="min-h-screen" style={{ paddingTop: (headerHeight || 0) + 8 }}>
      <Header onNext={() => goToOffset(1)} headerRef={headerRef} />

          <main ref={feedRef} className="max-w-xl mx-auto px-2 sm:px-4 pb-32 pt-4">
            <Diagnostics loading={loading} error={error} lastSource={lastSource} tried={triedSources} onOffline={() => {
              setMemes([]); setLastSource('offline'); setTriedSources(['manual']);
              setMemes(OFFLINE_MEMES.slice(0, BATCH_SIZE).sort((a,b)=> funnyScore(b)-funnyScore(a)));
            }} onRetry={() => { setError(''); fetchMemes(); }} />

            {memes.map((m, i) => (
              <article key={m.id || m.url} ref={el => (cardRefs.current[i] = el)}
                className="my-3 rounded-2xl overflow-hidden bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 shadow-sm">
                <header className="px-4 pt-3 pb-2 flex items-center justify-between">
                  <div className="min-w-0">
                    <h2 className="font-medium text-base truncate" title={m.title}>{m.title}</h2>
                    <p className="text-xs text-neutral-500">r/{m.subreddit || 'memes'} • by u/{m.author || 'someone'} • {m.ups ?? 0} upvotes</p>
                  </div>
                  <button onClick={() => toggleLike(m.id || m.url)} aria-label="Like this meme"
                    className={`ml-2 shrink-0 w-10 h-10 grid place-items-center rounded-full border ${liked.has(m.id || m.url) ? "bg-pink-500 text-white border-pink-500" : "border-neutral-300 dark:border-neutral-700 hover:bg-neutral-100 dark:hover:bg-neutral-800"}`}
                    title={liked.has(m.id || m.url) ? "Unlike (L)" : "Like (L)"}>
                    {liked.has(m.id || m.url) ? "❤" : "♡"}
                  </button>
                </header>

                <div className="bg-black/5 dark:bg-white/5">
                  <img src={m.url} alt={m.title} loading="lazy" className="w-full h-auto max-h-[80vh] object-contain bg-neutral-100 dark:bg-neutral-800"
                    onError={(e) => { e.currentTarget.closest("article")?.classList.add("hidden"); }} />
                </div>

                <footer className="px-4 py-3 flex items-center justify-between text-sm">
                  {m.postLink ? (<a className="underline-offset-2 hover:underline text-neutral-600 dark:text-neutral-300" href={m.postLink} target="_blank" rel="noreferrer">Open on Source</a>)
                              : <span className="text-neutral-500">Offline sample</span>}
                  <div className="flex items-center gap-2">
                    <button onClick={() => navigator.clipboard?.writeText(m.url)} className="px-3 py-1.5 rounded-full border border-neutral-300 dark:border-neutral-700 hover:bg-neutral-100 dark:hover:bg-neutral-800">Copy Image URL</button>
                    <button onClick={() => goToOffset(1)} className="px-3 py-1.5 rounded-full bg-black text-white dark:bg-white dark:text-black hover:opacity-90">Next</button>
                  </div>
                </footer>
              </article>
            ))}

            <div className="py-6">
              {loading && (
                <div className="animate-pulse space-y-3">
                  <div className="h-4 w-2/3 bg-neutral-200 dark:bg-neutral-800 rounded"></div>
                  <div className="h-[60vh] bg-neutral-200 dark:bg-neutral-800 rounded-2xl"></div>
                </div>
              )}
              <div ref={sentinelRef} className="h-8" />
              {memes.length === 0 && !loading && (
                <div className="text-center py-10 text-neutral-500">
                  <p>No memes available right now.</p>
                  <p className="text-sm">Try Retry or Use Offline.</p>
                </div>
              )}
            </div>
          </main>

          <div className="fixed bottom-4 inset-x-0 px-4">
            <div className="max-w-xl mx-auto rounded-full shadow-lg border border-neutral-200 dark:border-neutral-800 bg-white/90 dark:bg-neutral-900/90 backdrop-blur flex items-center justify-between px-3 py-2">
              <div className="text-xs text-neutral-500">{memes.length ? `${memes.length} loaded • src: ${lastSource || '...'}` : 'Loading...'}</div>
              <div className="flex items-center gap-2">
                <button onClick={() => {
                  const start = currentIndexRef.current;
                  const likedIds = memes.map(m => m.id || m.url).filter(id => liked.has(id));
                  const nextLiked = likedIds.find(id => memes.findIndex(m => (m.id||m.url) === id) > start) || likedIds[0];
                  if (!nextLiked) return;
                  const idx = memes.findIndex(m => (m.id||m.url) === nextLiked);
                  if (idx >= 0) {
                    currentIndexRef.current = idx;
                    const node = cardRefs.current[idx];
                    if (node) {
                      const header = document.querySelector('header');
                      const headerHeight = header ? header.offsetHeight : 0;
                      const offsetTop = node.offsetTop - headerHeight - 8;
                      window.scrollTo({ top: offsetTop, behavior: 'smooth' });
                    }
                  }
                }} className="px-3 py-1.5 rounded-full border border-neutral-300 dark:border-neutral-700 hover:bg-neutral-100 dark:hover:bg-neutral-800" title="Jump to next liked">Liked</button>
                <button onClick={() => goToOffset(1)} className="px-4 py-1.5 rounded-full bg-black text-white dark:bg-white dark:text-black hover:opacity-90" title="Next meme">Next</button>
              </div>
            </div>
          </div>

          {showTests && <TestOverlay results={testResults} onClose={() => setShowTests(false)} />}
          {/* ThemeToggle component instance REMOVED */}
        </div>
      );
    }

    function Header({ onNext, headerRef }) {
      return (
        <header ref={headerRef} className="sticky top-0 z-50 backdrop-blur bg-white/80 dark:bg-neutral-900/80 border-b border-neutral-200 dark:border-neutral-800">
          <div className="max-w-xl mx-auto flex items-center justify-between px-4 py-3 gap-2">
            <div className="flex items-center gap-2">
              <span className="text-xl">🤣</span>
              <h1 className="text-lg font-semibold tracking-tight">MemeStream</h1>
            </div>
            <div className="flex items-center gap-2">
              <button onClick={() => window.scrollTo({ top: 0, behavior: 'smooth' })} className="text-sm px-3 py-1.5 rounded-full border border-neutral-300 dark:border-neutral-700 hover:bg-neutral-100 dark:hover:bg-neutral-800" title="Back to top">Top</button>
              <button onClick={onNext} className="text-sm px-3 py-1.5 rounded-full bg-black text-white dark:bg-white dark:text-black hover:opacity-90" title="Next meme (J / ↓)">Next Meme</button>
            </div>
          </div>
          <div className="max-w-xl mx-auto px-4 pb-3"></div>
        </header>
      );
    }

    function Diagnostics({ loading, error, lastSource, tried, onOffline, onRetry }) {
      return (
        <div className="my-3 px-3 py-2 text-xs rounded-lg border border-neutral-200 dark:border-neutral-800 bg-neutral-50 dark:bg-neutral-900/60 text-neutral-600 dark:text-neutral-300">
          <div className="flex items-center justify-between">
            <div>source: <strong>{lastSource || '...'}</strong> • tried: {tried?.join(' → ') || '...'}</div>
            <div className="flex items-center gap-2">
              <button onClick={onRetry} className="px-2 py-1 rounded border border-neutral-300 dark:border-neutral-700 hover:bg-neutral-100 dark:hover:bg-neutral-800">Retry</button>
              <button onClick={onOffline} className="px-2 py-1 rounded bg-black text-white dark:bg-white dark:text-black hover:opacity-90">Use Offline</button>
            </div>
          </div>
          {error && <div className="mt-2 text-red-600 dark:text-red-400">{error}</div>}
          {loading && <div className="mt-2 text-green-600 dark:text-green-400">Loading…</div>}
        </div>
      );
    }

    /*******************
     * ---- HELPERS ----
     *******************/
    function toDateInput(d){ const y = d.getUTCFullYear(); const m = String(d.getUTCMonth()+1).padStart(2,'0'); const day = String(d.getUTCDate()).padStart(2,'0'); return `${y}-${m}-${day}`; }
    function atUTCStart(d){ return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 0,0,0)); }
    function atUTCEnd(d){ return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), 23,59,59)); }
    // removed date range helpers

    /*************************
     * ---- TEST RUNNER  ----
     *************************/
    function runTests(){
      const results = [];
      const assert = (name, cond) => results.push({ name, pass: !!cond });
      assert('isImageOrGif jpg', isImageOrGif('https://x/y.jpg'));
      assert('isImageOrGif negative txt', !isImageOrGif('https://x/y.txt'));
      const jan2025 = { created: Date.UTC(2025,0,10)/1000 }; const feb2025 = { created: Date.UTC(2025,1,3)/1000 };
      assert('monthYear in', isWithinRange(jan2025, { type: 'monthYear', month: 1, year: 2025 }));
      assert('monthYear out', !isWithinRange(feb2025, { type: 'monthYear', month: 1, year: 2025 }));
      const d1 = { created: Date.UTC(2024,6,1)/1000 }; const d2 = { created: Date.UTC(2024,6,15)/1000 };
      const r = { type: 'dateRange', from: new Date(Date.UTC(2024,6,5)), to: new Date(Date.UTC(2024,6,20)) };
      assert('dateRange before -> false', !isWithinRange(d1, r));
      assert('dateRange inside -> true', isWithinRange(d2, r));
      const s = [{ ups: 10 }, { ups: 1000 }];
      assert('funnyScore higher ups ranks first', [...s].sort((a,b)=> funnyScore(b)-funnyScore(a))[0].ups === 1000);
      assert('offline samples exist', OFFLINE_MEMES.length > 0 && OFFLINE_MEMES[0].url.startsWith('data:image/svg+xml'));
      return results;
    }

    function TestOverlay({ results, onClose }){
      return (
        <div className="fixed inset-0 z-[9999] bg-black/50 flex items-center justify-center p-4">
          <div className="w-full max-w-lg bg-white dark:bg-neutral-900 rounded-xl border border-neutral-200 dark:border-neutral-800 shadow-lg p-4">
            <div className="flex items-center justify-between mb-3">
              <h3 className="font-semibold">Test Results ({results.filter(r=>r.pass).length}/{results.length})</h3>
              <button onClick={onClose} className="px-3 py-1.5 rounded-full border border-neutral-300 dark:border-neutral-700">Close</button>
            </div>
            <ul className="space-y-1 text-sm max-h-64 overflow-auto pr-1">{results.map((r,i)=> (<li key={i} className={`flex items-center justify-between ${r.pass ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}><span className="truncate mr-2">{r.name}</span><span>{r.pass ? '✓' : '✗'}</span></li>))}</ul>
            <p className="mt-3 text-xs text-neutral-500">Tip: press <kbd className="px-1 border rounded">T</kbd> to toggle tests.</p>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>